Exam 3 Study Guide
==================

## Format

Exam 3 will take place in person on Wednesday, Apr 17 from 6-7:40pm. It will be 8-12 questions in length. You may be asked to define terminology, trace code, explain code, and write code. 

The format of the exam will be the same as prior exams; however, there will be no option to submit your solutions via GitHub. All solutions must be submitted through Canvas, and grading will be generous regarding indentation/formatting.

The exam will primarily focus on topics covered since Exam 2; however, there may be questions related to topics discussed in the first part of the semester. For example, it is likely there will be a recursion question on the exam!

## Topics

The exam may cover any topics we have discussed this semester. It is recommended that you review the Exam 1 and Exam 2 study guides as well.

The topics *emphasized* on Exam 3 will include the following:

* Classes and Objects
  - Define a class
  - Create instances of a class
  - Design a set of classes for a program.
* Testing
  - Design unit tests for a given program
* Stacks
  - Describe the result of applying one or more push/pop operations
  - Identify and fix bugs in a Stack implementation
  - Add additional operations to a Stack implementation
  - Use a Stack to solve a problem (e.g., determining whether parens are matching)
* Queues
  - Describe the result of applying one or more enqueue/dequeue operations
  - Identify and fix bugs in a Queue implementation that uses a circular buffer
* Efficiency
  - Determine the runtime bounds of an algorithm or code snippet (e.g., understand running time of operations on lists versus dictionaries)
  - Design a data structure to ensure a particular runtime bound for a given operation 
* Linear search
  - Find an item in a list
* Binary search
  - Identify and fix bugs in a binary search implementation
  - Trace the execution of a binary search implementation
* Sorting
  - Trace the execution of a sorting algorithm -- insertion, selection, or bubble sort

## Example Problems

**Question 1**
What is the result of applying the following operations on a ```Stack```? Provide the output of the code fragment.

```python
stack = Stack(5)
stack.push(23)
stack.push(37)
stack.push(92)
print(stack.pop())
stack.push(45)
print(stack.pop())
print(stack.pop())
```

**Question 2**
What is the result of applying the following operations on a ```Queue```? Provide the output of the code fragment.

```python
queue = Queue(5)

queue.enqueue(23)
queue.enqueue(37)
queue.enqueue(92)
print(queue.dequeue())
queue.enqueue(45)
print(queue.dequeue())
print(queue.dequeue())
```

**Question 3**
Consider a ```Stack``` implementation that uses a list to store the items in the ```Stack```. One possible implementation for ```push``` is to insert the new item at the beginning of the list. The implementation of ```pop``` then removes the item at position 0. Another possible implementation for ```push``` is to append the new item at the end of the list. The implementation of ```pop``` then removes the last item. Which approach is better *and why*?

**Question 4**
Given a ```Queue``` implemented using a circular buffer, what is the big-oh running time of the ```enqueue``` operation and the ```dequeue``` operation?

**Question 5**
[Partially generated by Chat GPT]

```python
class Item:
    def __init__(self, name, price):
        self.name = name
        self.price = price

class ShoppingCart:
    def __init__(self):
        self.items = []

    def add_item(self, item):
        self.items.append(item)

    def calculate_total_price(self):
        # Complete the implementation of this method to calculate the total price of all items in the shopping cart.
        pass

# Example usage:
# cart = ShoppingCart()
# cart.add_item(Item("Laptop", 1000))
# cart.add_item(Item("Mouse", 20))
# cart.add_item(Item("Keyboard", 50))
# total_price = cart.calculate_total_price()
# print("Total price of items in the cart:", total_price)
```

(a) Complete the implementation of the `calculate_total_price` method.
(b) Implement at least two unit test methods to test `calculate_total_price`.

**Question 6**
Consider a ```Gradebook``` application that stores```Student``` objects. The following logic adds a new score to a student's record.

```python

	def add_score(self, first, last, score):
		for student in self.students:
			if student.first == first and student.last == last:
				student.add_score(score)
				break
```
What is the big-oh running time of this method?

**Question 7**
Consider the ```Gradebook``` application described in Question 6. Would it be possible to modify the data structure(s) that store the student records such that the add_score method as shown above could be implemented to execute in O(1) time? If so, describe how. If not, describe why not.

**Question 8**
Consider an email application. Assume the top-level data structured used in the application is a dictionary that maps a username to a data structure that stores a collection of individual messages. Would you choose to store the collection of individual messages in a list or a dictionary? Explain your answer.

**Question 9**
```selection_sort``` works as follows:

```python
def selection_sort(things):
    '''
    Function: selection_sort -- sorting the elements of a list by inserting
                                each element into a list in order
    Parameters:
       things -- the elements to be sorted
    Returns a new list with all of the elements in sorted order
    '''
    for i in range(len(things) - 1):
        # select the next element by finding it in things
        min = i
        for j in range(i + 1, len(things)):
            if things[j] < things[min]:
                min = j
        things[i], things[min] = things[min], things[i]
    return things
```

Given the following input, show the state of the list things after every iteration of the outer for loop:

```things = [5, 2, 6, 1, 7, 3, 4]```

**Question 10**
Write a recursive function ```check_wordle``` that takes as input a wordle word and a guess and returns the number of *green* letters -- that is, the number of letters that are the same letter in the same position in both the wordle word and the guess.